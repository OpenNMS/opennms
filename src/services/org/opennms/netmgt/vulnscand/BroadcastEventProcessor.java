//
// Copyright (C) 1999-2001 Oculan Corp.  All rights reserved.
// Copyright (C) 2001 Oculan Corp.  All rights reserved.
//  
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software 
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
// 
// For more information contact: 
//	Brian Weaver	<weave@opennms.org>
//	http://www.opennms.org/
//
// Tab Size = 8
//
package org.opennms.netmgt.vulnscand;

import java.lang.*;

import java.io.StringReader;

import java.net.InetAddress;

import java.util.Properties;
import java.util.Enumeration;
import java.util.List;
import java.util.ArrayList;

import org.apache.log4j.Category;

import org.exolab.castor.xml.Unmarshaller;
import org.exolab.castor.xml.ValidationException;
import org.exolab.castor.xml.MarshalException;

import org.opennms.core.queue.FifoQueue;
import org.opennms.core.queue.FifoQueueException;
import org.opennms.core.utils.ThreadCategory;

import org.opennms.netmgt.eventd.EventIpcManagerFactory;
import org.opennms.netmgt.eventd.EventListener;

import org.opennms.netmgt.EventConstants;

import org.opennms.netmgt.config.DatabaseConnectionFactory;

// These generated by castor
//
import org.opennms.netmgt.xml.event.Log;
import org.opennms.netmgt.xml.event.Events;
import org.opennms.netmgt.xml.event.Event;

/**
 *
 * @author <a href="mailto:seth@opennms.org">Seth Leger</a>
 * @author <a href="mailto:weave@opennms.org">Brian Weaver</a>
 * @author <a href="http://www.opennms.org/">OpenNMS</a>
 */
final class BroadcastEventProcessor
	implements EventListener
{
	/**
	 * SQL query to retrieve nodeid of a particulary interface address
	 */
	private static String 	SQL_RETRIEVE_NODEID = "select nodeid from ipinterface where ipaddr=? and isManaged!='D'";
	
	/**
	 * The location where suspectInterface events are enqueued
	 * for processing.
	 */
	private FifoQueue	m_suspectQ;

	/**
	 * The Vulnscand rescan scheduler
	 */
	private Scheduler 	m_scheduler;

	/**
	 * Create message selector to set to the subscription
	 */
	private void installJmsMessageSelector()
	{
		// Create the JMS selector for the ueis this service is interested in
		//
		List ueiList = new ArrayList();

		// specificVulnerabilityScan
		ueiList.add(EventConstants.SPECIFIC_VULN_SCAN_EVENT_UEI);

		EventIpcManagerFactory.getInstance().getManager().addEventListener(this, ueiList);
	}

	/**
	 * This constructor is called to initilize the JMS event receiver.
	 * A connection to the message server is opened and this instance
	 * is setup as the endpoint for broadcast events. When a new
	 * event arrives it is processed and the appropriate action
	 * is taken.
	 *
	 * @param suspectQ	The queue where new Runnable objects
	 *                      are enqueued for running..
	 * @param scheduler	Rescan scheduler.
	 *
	 */
	BroadcastEventProcessor(FifoQueue suspectQ, Scheduler scheduler)
	{
		Category log = ThreadCategory.getInstance(getClass());

		// Suspect queue
		//
		m_suspectQ = suspectQ;

		// Scheduler
		//
		m_scheduler = scheduler;
		
		installJmsMessageSelector();
	}

	/**
	 * </p>Closes the current connections to the Java
	 * Message Queue if they are still active. This
	 * call may be invoked more than once safely and
	 * may be invoked during object finalization.</p>
	 *
	 */
	synchronized void close()
	{
		EventIpcManagerFactory.getInstance().getManager().removeEventListener(this);
	}

	/**
	 * This method may be invoked by the garbage collection. Once
	 * invoked it ensures that the <code>close</code> method is
	 * called <em>at least</em> once during the cycle of this
	 * object.
	 *
	 */
	protected void finalize()
		throws Throwable
	{
		close(); // ensure it's closed
	}

	/**
	 * This method is invoked by the JMS topic session
	 * when a new event is available for processing. Currently
	 * only text based messages are processed by this callback.
	 * Each message is examined for its Universal Event Identifier
	 * and the appropriate action is taking based on each UEI.
	 *
	 * @param emsg	The event message.
	 *
	 */
	public void onEvent(Event event)
	{
		Category log = ThreadCategory.getInstance(getClass());

		String eventUei = event.getUei();
		if (eventUei == null)
			return;

		if (log.isDebugEnabled())
			log.debug("Received event: " + eventUei);

		if(eventUei.equals(EventConstants.SPECIFIC_VULN_SCAN_EVENT_UEI))
		{

// ADD RESCAN CAPABILITIES HERE
// NEED TO GET THE SCAN LEVEL,
// LAST SCAN DATE FROM THE DATABASE,
// AND THE RESCAN INTERVAL

/*
			// new poll event
			try
			{
				if (log.isDebugEnabled())
					log.debug("onMessage: Adding interface to suspectInterface Q: " + event.getInterface());
				m_suspectQ.add(new NessusScan(new NessusScanConfiguration(InetAddress.getByName(event.getInterface()), int newScanLevel, Date newLastScan, long newInterval)));
			}
			catch (java.net.UnknownHostException ex)
			{
				log.error("onMessage: Could not schedule invalid interface: \"" + event.getInterface() + "\"", ex);
			}
			catch(Exception ex)
			{
				log.error("onMessage: Failed to add interface \"" + event.getInterface() + "\" to suspect queue", ex);
			}
*/
		}
		else
		{
			log.error("Cannot process event with UEI: " + event.getUei());
		}
	} // end onEvent()

	public String getName()
	{
		return "Vulnscand:BroadcastEventProcessor";
	}
} // end class
