import type * as vscode from 'vscode-languageserver';
import { TextDocument } from 'vscode-languageserver-textdocument';
import type * as ts from 'typescript/lib/tsserverlibrary';
import { ApiLanguageServiceContext, Modules } from './types';
import * as formatting from './services/formatting';
import * as emmet from '@vscode/emmet-helper';
import * as css from 'vscode-css-languageservice';
import * as json from 'vscode-json-languageservice';
import * as ts2 from 'vscode-typescript-languageservice';
export declare type DocumentLanguageService = ReturnType<typeof getDocumentLanguageService>;
export declare type LanguageService = ReturnType<typeof createLanguageService>;
export declare type LanguageServiceHost = ts2.LanguageServiceHost & {
    createTsLanguageService?(host: ts.LanguageServiceHost): ts.LanguageService;
    getEmmetConfig?(syntax: string): Promise<emmet.VSCodeEmmetConfig> | emmet.VSCodeEmmetConfig;
    schemaRequestService?: json.SchemaRequestService;
};
export declare function getDocumentLanguageService(modules: {
    typescript: Modules['typescript'];
}, getPreferences: LanguageServiceHost['getPreferences'], getFormatOptions: LanguageServiceHost['getFormatOptions'], formatters: Parameters<typeof formatting['register']>[3]): {
    doFormatting: (document: TextDocument, options: vscode.FormattingOptions) => Promise<vscode.TextEdit[] | undefined>;
    getFoldingRanges: (document: TextDocument) => vscode.FoldingRange[];
    getSelectionRanges: (document: TextDocument, positions: vscode.Position[]) => vscode.SelectionRange[];
    doTagComplete: (document: TextDocument, position: vscode.Position) => string | null | undefined;
    findLinkedEditingRanges: (document: TextDocument, position: vscode.Position) => vscode.LinkedEditingRanges | null;
    findDocumentSymbols: (document: TextDocument) => vscode.SymbolInformation[];
    findDocumentColors: (document: TextDocument) => vscode.ColorInformation[];
    getColorPresentations: (document: TextDocument, color: vscode.Color, range: vscode.Range) => vscode.ColorPresentation[];
};
export declare function createLanguageService(modules: {
    typescript: Modules['typescript'];
}, vueHost: LanguageServiceHost, isTsPlugin?: boolean): {
    doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<vscode.Diagnostic[] | undefined>;
    findDefinition: (uri: string, position: vscode.Position) => vscode.LocationLink[] | vscode.Location[];
    findReferences: (uri: string, position: vscode.Position) => vscode.Location[];
    findTypeDefinition: (uri: string, position: vscode.Position) => vscode.LocationLink[];
    callHierarchy: {
        doPrepare: (uri: string, position: vscode.Position) => vscode.CallHierarchyItem[];
        getIncomingCalls: (item: vscode.CallHierarchyItem) => vscode.CallHierarchyIncomingCall[];
        getOutgoingCalls: (item: vscode.CallHierarchyItem) => vscode.CallHierarchyOutgoingCall[];
    };
    prepareRename: (uri: string, position: vscode.Position) => vscode.Range | vscode.ResponseError<void> | undefined;
    doRename: (uri: string, position: vscode.Position, newName: string) => Promise<vscode.WorkspaceEdit | undefined>;
    getEditsForFileRename: (oldUri: string, newUri: string) => Promise<vscode.WorkspaceEdit | undefined>;
    getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => vscode.SemanticTokens | undefined;
    doHover: (uri: string, position: vscode.Position) => vscode.Hover | undefined;
    doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
        tagNameCase: "both" | "kebabCase" | "pascalCase";
        attrNameCase: "kebabCase" | "pascalCase";
    }>) | undefined) => Promise<css.CompletionList | undefined>;
    getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<vscode.CodeAction[]>;
    doCodeActionResolve: (codeAction: css.CodeAction) => Promise<css.CodeAction>;
    doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<vscode.CompletionItem>;
    doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => vscode.CodeLens;
    getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => vscode.SignatureHelp | undefined;
    getCodeLens: (uri: string) => vscode.CodeLens[] | undefined;
    findDocumentHighlights: (uri: string, position: vscode.Position) => vscode.DocumentHighlight[] | undefined;
    findDocumentLinks: (uri: string) => Promise<vscode.DocumentLink[] | undefined>;
    dispose: () => void;
    __internal__: {
        rootPath: string;
        tsPlugin: Partial<ts.LanguageService>;
        tsProgramProxy: any;
        context: ApiLanguageServiceContext;
        onInitProgress(cb: (p: number) => void): void;
        checkProject: () => boolean;
        getGlobalDocs: () => TextDocument[];
        getContext: () => ApiLanguageServiceContext;
        getD3: (document: TextDocument) => Promise<string>;
        executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<void>;
        detectTagNameCase: (uri: string) => {
            tag: "both" | "kebabCase" | "pascalCase" | "unsure";
            attr: "kebabCase" | "pascalCase" | "unsure";
        };
        doRefAutoClose: (document: TextDocument, position: vscode.Position) => string | null | undefined;
    };
};
