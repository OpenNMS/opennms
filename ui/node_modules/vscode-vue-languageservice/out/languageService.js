"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getDocumentLanguageService = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared = require("@volar/shared");
const sourceFile_1 = require("./sourceFile");
const globalDoc_1 = require("./utils/globalDoc");
const upath = require("upath");
const tsPluginApis = require("./tsPluginApis");
const tsProgramApis = require("./tsProgramApis");
// vue services
const completions = require("./services/completion");
const completionResolve = require("./services/completionResolve");
const autoClose = require("./services/autoClose");
const refAutoClose = require("./services/refAutoClose");
const hover = require("./services/hover");
const diagnostics = require("./services/diagnostics");
const formatting = require("./services/formatting");
const definitions = require("./services/definition");
const references = require("./services/references");
const rename = require("./services/rename");
const codeActions = require("./services/codeAction");
const codeActionResolve = require("./services/codeActionResolve");
const documentHighlight = require("./services/documentHighlight");
const documentSymbol = require("./services/documentSymbol");
const documentLink = require("./services/documentLinks");
const documentColor = require("./services/documentColor");
const selectionRanges = require("./services/selectionRanges");
const signatureHelp = require("./services/signatureHelp");
const colorPresentations = require("./services/colorPresentation");
const semanticTokens = require("./services/semanticTokens");
const foldingRanges = require("./services/foldingRanges");
const codeLens = require("./services/codeLens");
const codeLensResolve = require("./services/codeLensResolve");
const executeCommand = require("./services/executeCommand");
const callHierarchy = require("./services/callHierarchy");
const linkedEditingRanges = require("./services/linkedEditingRange");
const tagNameCase = require("./services/tagNameCase");
const d3 = require("./services/d3");
// context
const fs = require("fs");
const emmet = require("@vscode/emmet-helper");
const css = require("vscode-css-languageservice");
const html = require("vscode-html-languageservice");
const json = require("vscode-json-languageservice");
const ts2 = require("vscode-typescript-languageservice");
const pug = require("vscode-pug-languageservice");
const sourceFiles_1 = require("./sourceFiles");
function getDocumentLanguageService(modules, getPreferences, getFormatOptions, formatters) {
    const htmlDocuments = new WeakMap();
    const vueDocuments = new WeakMap();
    const context = {
        isVue2Mode: false,
        modules: {
            typescript: modules.typescript,
            emmet,
            css,
            html,
            json,
            ts: ts2,
            pug
        },
        ...createContext(modules.typescript),
        getHtmlDocument,
        getVueDocument,
    };
    return {
        doFormatting: formatting.register(context, getPreferences, getFormatOptions, formatters),
        getFoldingRanges: foldingRanges.register(context, getPreferences, getFormatOptions),
        getSelectionRanges: selectionRanges.register(context, getPreferences, getFormatOptions),
        doTagComplete: autoClose.register(context),
        findLinkedEditingRanges: linkedEditingRanges.register(context),
        findDocumentSymbols: documentSymbol.register(context, getPreferences, getFormatOptions),
        findDocumentColors: documentColor.register(context),
        getColorPresentations: colorPresentations.register(context),
    };
    function getVueDocument(document) {
        const cacheVueDoc = vueDocuments.get(document);
        if (cacheVueDoc) {
            const oldText = cacheVueDoc.getTextDocument().getText();
            const newText = document.getText();
            if (oldText.length !== newText.length || oldText !== newText) {
                cacheVueDoc.update(document);
            }
            return cacheVueDoc;
        }
        const vueDoc = sourceFile_1.createSourceFile(document, context);
        vueDocuments.set(document, vueDoc);
        return vueDoc;
    }
    function getHtmlDocument(document) {
        const cache = htmlDocuments.get(document);
        if (cache) {
            const [cacheVersion, cacheHtmlDoc] = cache;
            if (cacheVersion === document.version) {
                return cacheHtmlDoc;
            }
        }
        const htmlDoc = context.htmlLs.parseHTMLDocument(document);
        htmlDocuments.set(document, [document.version, htmlDoc]);
        return htmlDoc;
    }
}
exports.getDocumentLanguageService = getDocumentLanguageService;
function createLanguageService(modules, vueHost, isTsPlugin = false) {
    var _a;
    const { typescript: ts } = modules;
    let vueProjectVersion;
    let lastScriptVersions = new Map();
    let scriptProjectVersion = 0;
    let templateProjectVersion = 0;
    let lastScriptProjectVersionWhenTemplateProjectVersionUpdate = -1;
    const documents = new shared.UriMap();
    const sourceFiles = sourceFiles_1.createSourceFiles();
    const templateScriptUpdateUris = new Set();
    const initProgressCallback = [];
    const templateTsHost = createTsLsHost('template');
    const scriptTsHost = createTsLsHost('script');
    const templateTsLsRaw = vueHost.createTsLanguageService ? vueHost.createTsLanguageService(templateTsHost) : ts.createLanguageService(templateTsHost);
    const scriptTsLsRaw = vueHost.createTsLanguageService ? vueHost.createTsLanguageService(scriptTsHost) : ts.createLanguageService(scriptTsHost);
    const templateTsLs = ts2.createLanguageService(ts, templateTsHost, templateTsLsRaw);
    const scriptTsLs = ts2.createLanguageService(ts, scriptTsHost, scriptTsLsRaw);
    const globalDoc = globalDoc_1.createGlobalDefineDocument(vueHost.getCurrentDirectory());
    const compilerHost = ts.createCompilerHost(vueHost.getCompilationSettings());
    const documentContext = {
        resolveReference(ref, base) {
            const resolveResult = ts.resolveModuleName(ref, base, vueHost.getCompilationSettings(), compilerHost);
            const failedLookupLocations = resolveResult.failedLookupLocations;
            const dirs = new Set();
            for (const failed of failedLookupLocations) {
                let path = failed;
                if (path.endsWith('index.d.ts')) {
                    dirs.add(path.substr(0, path.length - '/index.d.ts'.length));
                }
                if (path.endsWith('.d.ts')) {
                    path = upath.trimExt(path);
                    path = upath.trimExt(path);
                }
                else {
                    path = upath.trimExt(path);
                }
                if (ts.sys.fileExists(path) || ts.sys.fileExists(shared.uriToFsPath(path))) {
                    return path;
                }
            }
            for (const dir of dirs) {
                if (ts.sys.directoryExists(dir) || ts.sys.directoryExists(shared.uriToFsPath(dir))) {
                    return dir;
                }
            }
            return undefined;
        },
    };
    const tsconfigFile = upath.join(vueHost.getCurrentDirectory(), 'tsconfig.json');
    const jsconfigFile = upath.join(vueHost.getCurrentDirectory(), 'jsconfig.json');
    const configFile = ts.sys.fileExists(tsconfigFile) ? tsconfigFile : ts.sys.fileExists(jsconfigFile) ? jsconfigFile : undefined;
    const config = configFile ? shared.createParsedCommandLine(ts, ts.sys, configFile) : undefined;
    const context = {
        isVue2Mode: ((_a = config === null || config === void 0 ? void 0 : config.raw.vueCompilerOptions) === null || _a === void 0 ? void 0 : _a.experimentalCompatMode) === 2,
        modules: {
            typescript: modules.typescript,
            emmet,
            css,
            html,
            json,
            ts: ts2,
            pug
        },
        ...createContext(modules.typescript, vueHost),
        vueHost,
        sourceFiles,
        templateTsHost,
        scriptTsHost,
        templateTsLsRaw,
        scriptTsLsRaw,
        templateTsLs,
        scriptTsLs,
        documentContext,
        getTsLs: (lsType) => lsType === 'template' ? templateTsLs : scriptTsLs,
    };
    const _callHierarchy = callHierarchy.register(context);
    const findDefinition = definitions.register(context);
    const renames = rename.register(context);
    // ts plugin proxy
    const _tsPluginApis = tsPluginApis.register(context);
    const tsPlugin = {
        getSemanticDiagnostics: apiHook(scriptTsLsRaw.getSemanticDiagnostics, false),
        getEncodedSemanticClassifications: apiHook(scriptTsLsRaw.getEncodedSemanticClassifications, false),
        getCompletionsAtPosition: apiHook(_tsPluginApis.getCompletionsAtPosition, false),
        getCompletionEntryDetails: apiHook(scriptTsLsRaw.getCompletionEntryDetails, false),
        getCompletionEntrySymbol: apiHook(scriptTsLsRaw.getCompletionEntrySymbol, false),
        getQuickInfoAtPosition: apiHook(scriptTsLsRaw.getQuickInfoAtPosition, false),
        getSignatureHelpItems: apiHook(scriptTsLsRaw.getSignatureHelpItems, false),
        getRenameInfo: apiHook(scriptTsLsRaw.getRenameInfo, false),
        findRenameLocations: apiHook(_tsPluginApis.findRenameLocations, true),
        getDefinitionAtPosition: apiHook(_tsPluginApis.getDefinitionAtPosition, false),
        getDefinitionAndBoundSpan: apiHook(_tsPluginApis.getDefinitionAndBoundSpan, false),
        getTypeDefinitionAtPosition: apiHook(_tsPluginApis.getTypeDefinitionAtPosition, false),
        getImplementationAtPosition: apiHook(_tsPluginApis.getImplementationAtPosition, false),
        getReferencesAtPosition: apiHook(_tsPluginApis.getReferencesAtPosition, true),
        findReferences: apiHook(_tsPluginApis.findReferences, true),
        // TODO: now is handle by vue server
        // prepareCallHierarchy: apiHook(tsLanguageService.rawLs.prepareCallHierarchy, false),
        // provideCallHierarchyIncomingCalls: apiHook(tsLanguageService.rawLs.provideCallHierarchyIncomingCalls, false),
        // provideCallHierarchyOutgoingCalls: apiHook(tsLanguageService.rawLs.provideCallHierarchyOutgoingCalls, false),
        // getEditsForFileRename: apiHook(tsLanguageService.rawLs.getEditsForFileRename, false),
        // TODO
        // getCodeFixesAtPosition: apiHook(tsLanguageService.rawLs.getCodeFixesAtPosition, false),
        // getCombinedCodeFix: apiHook(tsLanguageService.rawLs.getCombinedCodeFix, false),
        // applyCodeActionCommand: apiHook(tsLanguageService.rawLs.applyCodeActionCommand, false),
        // getApplicableRefactors: apiHook(tsLanguageService.rawLs.getApplicableRefactors, false),
        // getEditsForRefactor: apiHook(tsLanguageService.rawLs.getEditsForRefactor, false),
    };
    // ts program proxy
    const tsProgram = scriptTsLsRaw.getProgram(); // TODO: handle template ls?
    if (!tsProgram)
        throw '!tsProgram';
    const tsProgramApis_2 = tsProgramApis.register(context);
    const tsProgramApis_3 = {
        emit: apiHook(tsProgramApis_2.emit),
        getRootFileNames: apiHook(tsProgramApis_2.getRootFileNames),
        getSemanticDiagnostics: apiHook(tsProgramApis_2.getSemanticDiagnostics),
        getSyntacticDiagnostics: apiHook(tsProgramApis_2.getSyntacticDiagnostics),
        getGlobalDiagnostics: apiHook(tsProgramApis_2.getGlobalDiagnostics),
    };
    const tsProgramProxy = new Proxy(tsProgram, {
        get: (target, property) => {
            return tsProgramApis_3[property] || target[property];
        },
    });
    return {
        doValidation: apiHook(diagnostics.register(context, () => update(true)), false),
        findDefinition: apiHook(findDefinition.on, isTemplateScriptPosition),
        findReferences: apiHook(references.register(context), true),
        findTypeDefinition: apiHook(findDefinition.onType, isTemplateScriptPosition),
        callHierarchy: {
            doPrepare: apiHook(_callHierarchy.doPrepare, isTemplateScriptPosition),
            getIncomingCalls: apiHook(_callHierarchy.getIncomingCalls, true),
            getOutgoingCalls: apiHook(_callHierarchy.getOutgoingCalls, true),
        },
        prepareRename: apiHook(renames.prepareRename, isTemplateScriptPosition),
        doRename: apiHook(renames.doRename, true),
        getEditsForFileRename: apiHook(renames.onRenameFile, false),
        getSemanticTokens: apiHook(semanticTokens.register(context, () => update(true)), false),
        doHover: apiHook(hover.register(context), isTemplateScriptPosition),
        doComplete: apiHook(completions.register(context), isTemplateScriptPosition),
        getCodeActions: apiHook(codeActions.register(context), false),
        doCodeActionResolve: apiHook(codeActionResolve.register(context), false),
        doCompletionResolve: apiHook(completionResolve.register(context), false),
        doCodeLensResolve: apiHook(codeLensResolve.register(context), false),
        getSignatureHelp: apiHook(signatureHelp.register(context), false),
        getCodeLens: apiHook(codeLens.register(context), false),
        findDocumentHighlights: apiHook(documentHighlight.register(context), false),
        findDocumentLinks: apiHook(documentLink.register(context), false),
        dispose: () => {
            scriptTsLs.dispose();
            templateTsLs.dispose();
        },
        __internal__: {
            rootPath: vueHost.getCurrentDirectory(),
            tsPlugin,
            tsProgramProxy,
            context,
            onInitProgress(cb) {
                initProgressCallback.push(cb);
            },
            checkProject: apiHook(() => {
                const vueImportErrors = scriptTsLs.doValidation(globalDoc.uri, { semantic: true });
                return !vueImportErrors.find(error => error.code === 2322); // Type 'false' is not assignable to type 'true'.ts(2322)
            }, false),
            getGlobalDocs: () => [globalDoc],
            getContext: apiHook(() => context),
            getD3: apiHook(d3.register(context)),
            executeCommand: apiHook(executeCommand.register(context)),
            detectTagNameCase: apiHook(tagNameCase.register(context)),
            doRefAutoClose: apiHook(refAutoClose.register(context), false),
        },
    };
    function isTemplateScriptPosition(uri, pos) {
        const sourceFile = sourceFiles.get(uri);
        if (!sourceFile) {
            return false;
        }
        for (const sourceMap of sourceFile.getTsSourceMaps()) {
            if (sourceMap.lsType === 'script')
                continue;
            for (const tsRange of sourceMap.getMappedRanges(pos)) {
                if (tsRange.data.vueTag === 'template') {
                    return true;
                }
            }
        }
        for (const sourceMap of sourceFile.getHtmlSourceMaps()) {
            for (const _ of sourceMap.getMappedRanges(pos)) {
                return true;
            }
        }
        return false;
    }
    function apiHook(api, shouldUpdateTemplateScript = true) {
        const handler = {
            apply: function (target, thisArg, argumentsList) {
                if (typeof shouldUpdateTemplateScript === 'boolean') {
                    update(shouldUpdateTemplateScript);
                }
                else {
                    update(shouldUpdateTemplateScript.apply(null, argumentsList));
                }
                return target.apply(thisArg, argumentsList);
            }
        };
        return new Proxy(api, handler);
    }
    function update(shouldUpdateTemplateScript) {
        var _a;
        const newVueProjectVersion = (_a = vueHost.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(vueHost);
        if (newVueProjectVersion === undefined || newVueProjectVersion !== vueProjectVersion) {
            let tsFileChanged = false;
            vueProjectVersion = newVueProjectVersion;
            const oldFiles = new Set([...lastScriptVersions.keys()]);
            const newFiles = new Set([...vueHost.getScriptFileNames()]);
            const removes = [];
            const adds = [];
            const updates = [];
            for (const fileName of oldFiles) {
                if (!newFiles.has(fileName)) {
                    if (fileName.endsWith('.vue')) {
                        removes.push(fileName);
                    }
                    else {
                        tsFileChanged = true;
                    }
                    lastScriptVersions.delete(fileName);
                }
            }
            for (const fileName of newFiles) {
                if (!oldFiles.has(fileName)) {
                    if (fileName.endsWith('.vue')) {
                        adds.push(fileName);
                    }
                    else {
                        tsFileChanged = true;
                    }
                    lastScriptVersions.set(fileName, vueHost.getScriptVersion(fileName));
                }
            }
            for (const fileName of oldFiles) {
                if (newFiles.has(fileName)) {
                    const oldVersion = lastScriptVersions.get(fileName);
                    const newVersion = vueHost.getScriptVersion(fileName);
                    if (oldVersion !== newVersion) {
                        if (fileName.endsWith('.vue')) {
                            updates.push(fileName);
                        }
                        else {
                            tsFileChanged = true;
                        }
                        lastScriptVersions.set(fileName, newVersion);
                    }
                }
            }
            if (tsFileChanged) {
                scriptProjectVersion++;
                templateProjectVersion++;
                updates.length = 0;
                for (const fileName of oldFiles) {
                    if (newFiles.has(fileName)) {
                        if (fileName.endsWith('.vue')) {
                            updates.push(fileName);
                        }
                    }
                }
            }
            const finalUpdates = adds.concat(updates);
            if (removes.length) {
                unsetSourceFiles(removes.map(shared.fsPathToUri));
            }
            if (finalUpdates.length) {
                updateSourceFiles(finalUpdates.map(shared.fsPathToUri), shouldUpdateTemplateScript);
            }
        }
        else if (shouldUpdateTemplateScript && templateScriptUpdateUris.size) {
            updateSourceFiles([], shouldUpdateTemplateScript);
        }
    }
    function createTsLsHost(lsType) {
        const scriptSnapshots = new Map();
        const tsHost = {
            ...vueHost,
            fileExists: vueHost.fileExists
                ? fileName => {
                    var _a, _b;
                    // .vue.js -> .vue
                    // .vue.ts -> .vue
                    // .vue.d.ts (never)
                    const fileNameTrim = upath.trimExt(fileName);
                    if (fileNameTrim.endsWith('.vue')) {
                        let sourceFile = sourceFiles.get(shared.fsPathToUri(fileNameTrim));
                        if (!sourceFile) {
                            const fileExists = !!((_a = vueHost.fileExists) === null || _a === void 0 ? void 0 : _a.call(vueHost, fileNameTrim));
                            if (fileExists) {
                                vueProjectVersion += '-old'; // force update
                                update(false); // create virtual files
                            }
                        }
                        return sourceFiles.getTsDocuments(lsType).has(shared.fsPathToUri(fileName));
                    }
                    else {
                        return !!((_b = vueHost.fileExists) === null || _b === void 0 ? void 0 : _b.call(vueHost, fileName));
                    }
                }
                : undefined,
            getProjectVersion: () => {
                var _a;
                return ((_a = vueHost.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(vueHost)) + ':' + (lsType === 'template' ? templateProjectVersion : scriptProjectVersion);
            },
            getScriptFileNames,
            getScriptVersion,
            getScriptSnapshot,
            readDirectory: (path, extensions, exclude, include, depth) => {
                var _a, _b;
                const result = (_b = (_a = vueHost.readDirectory) === null || _a === void 0 ? void 0 : _a.call(vueHost, path, extensions, exclude, include, depth)) !== null && _b !== void 0 ? _b : [];
                for (const uri of sourceFiles.getUris()) {
                    const vuePath = shared.uriToFsPath(uri);
                    const vuePath2 = upath.join(path, upath.basename(vuePath));
                    if (upath.relative(path.toLowerCase(), vuePath.toLowerCase()).startsWith('..')) {
                        continue;
                    }
                    if (!depth && vuePath.toLowerCase() === vuePath2.toLowerCase()) {
                        result.push(vuePath2);
                    }
                    else if (depth) {
                        result.push(vuePath2); // TODO: depth num
                    }
                }
                return result;
            },
            getScriptKind(fileName) {
                switch (upath.extname(fileName)) {
                    case '.vue': return ts.ScriptKind.TSX; // can't use External, Unknown
                    case '.js': return ts.ScriptKind.JS;
                    case '.jsx': return ts.ScriptKind.JSX;
                    case '.ts': return ts.ScriptKind.TS;
                    case '.tsx': return ts.ScriptKind.TSX;
                    case '.json': return ts.ScriptKind.JSON;
                    default: return ts.ScriptKind.Unknown;
                }
            },
        };
        return tsHost;
        function getScriptFileNames() {
            const tsFileNames = [];
            tsFileNames.push(shared.uriToFsPath(globalDoc.uri));
            for (const [tsUri] of sourceFiles.getTsDocuments(lsType)) {
                tsFileNames.push(shared.uriToFsPath(tsUri)); // virtual .ts
            }
            for (const fileName of vueHost.getScriptFileNames()) {
                if (isTsPlugin) {
                    tsFileNames.push(fileName); // .vue + .ts
                }
                else if (!fileName.endsWith('.vue')) {
                    tsFileNames.push(fileName); // .ts
                }
            }
            return tsFileNames;
        }
        function getScriptVersion(fileName) {
            const uri = shared.fsPathToUri(fileName);
            if (uri === globalDoc.uri) {
                return globalDoc.version.toString();
            }
            let doc = sourceFiles.getTsDocuments(lsType).get(uri);
            if (doc) {
                return doc.version.toString();
            }
            return vueHost.getScriptVersion(fileName);
        }
        function getScriptSnapshot(fileName) {
            const version = getScriptVersion(fileName);
            const cache = scriptSnapshots.get(fileName);
            if (cache && cache[0] === version) {
                return cache[1];
            }
            const uri = shared.fsPathToUri(fileName);
            if (uri === globalDoc.uri) {
                const text = globalDoc.getText();
                const snapshot = ts.ScriptSnapshot.fromString(text);
                scriptSnapshots.set(fileName, [version, snapshot]);
                return snapshot;
            }
            const doc = sourceFiles.getTsDocuments(lsType).get(uri);
            if (doc) {
                const text = doc.getText();
                const snapshot = ts.ScriptSnapshot.fromString(text);
                scriptSnapshots.set(fileName, [version, snapshot]);
                return snapshot;
            }
            let tsScript = vueHost.getScriptSnapshot(fileName);
            if (tsScript) {
                scriptSnapshots.set(fileName, [version, tsScript]);
                return tsScript;
            }
        }
    }
    function getHostDocument(uri) {
        const fileName = shared.uriToFsPath(uri);
        const version = Number(vueHost.getScriptVersion(fileName));
        if (!documents.has(uri) || documents.get(uri).version !== version) {
            const scriptSnapshot = vueHost.getScriptSnapshot(fileName);
            if (scriptSnapshot) {
                const scriptText = scriptSnapshot.getText(0, scriptSnapshot.getLength());
                const document = vscode_languageserver_textdocument_1.TextDocument.create(uri, uri.endsWith('.vue') ? 'vue' : 'typescript', version, scriptText);
                documents.set(uri, document);
            }
        }
        if (documents.has(uri)) {
            return documents.get(uri);
        }
    }
    function updateSourceFiles(uris, shouldUpdateTemplateScript) {
        var _a;
        let vueScriptsUpdated = false;
        let templateScriptUpdated = false;
        if (shouldUpdateTemplateScript) {
            for (const cb of initProgressCallback) {
                cb(0);
            }
        }
        for (const uri of uris) {
            const sourceFile = sourceFiles.get(uri);
            const doc = getHostDocument(uri);
            if (!doc)
                continue;
            if (!sourceFile) {
                sourceFiles.set(uri, sourceFile_1.createSourceFile(doc, context));
                vueScriptsUpdated = true;
            }
            else {
                const updates = sourceFile.update(doc);
                if (updates.scriptUpdated) {
                    vueScriptsUpdated = true;
                }
                if (updates.templateScriptUpdated) {
                    templateScriptUpdated = true;
                }
            }
            templateScriptUpdateUris.add(uri);
        }
        if (vueScriptsUpdated) {
            scriptProjectVersion++;
            templateProjectVersion++;
        }
        if (shouldUpdateTemplateScript && lastScriptProjectVersionWhenTemplateProjectVersionUpdate !== scriptProjectVersion) {
            lastScriptProjectVersionWhenTemplateProjectVersionUpdate = scriptProjectVersion;
            let currentNums = 0;
            for (const uri of templateScriptUpdateUris) {
                if ((_a = sourceFiles.get(uri)) === null || _a === void 0 ? void 0 : _a.updateTemplateScript(templateTsLs)) {
                    templateScriptUpdated = true;
                }
                for (const cb of initProgressCallback) {
                    cb(++currentNums / templateScriptUpdateUris.size);
                }
            }
            templateScriptUpdateUris.clear();
            for (const cb of initProgressCallback) {
                cb(1);
            }
            initProgressCallback.length = 0;
        }
        if (templateScriptUpdated) {
            templateProjectVersion++;
        }
    }
    function unsetSourceFiles(uris) {
        let updated = false;
        for (const uri of uris) {
            if (sourceFiles.delete(uri)) {
                updated = true;
            }
        }
        if (updated) {
            scriptProjectVersion++;
            templateProjectVersion++;
        }
    }
}
exports.createLanguageService = createLanguageService;
function createContext(ts, vueHost) {
    const fileSystemProvider = {
        stat: (uri) => {
            return new Promise((resolve, reject) => {
                fs.stat(shared.uriToFsPath(uri), (err, stats) => {
                    if (stats) {
                        resolve({
                            type: stats.isFile() ? html.FileType.File
                                : stats.isDirectory() ? html.FileType.Directory
                                    : stats.isSymbolicLink() ? html.FileType.SymbolicLink
                                        : html.FileType.Unknown,
                            ctime: stats.ctimeMs,
                            mtime: stats.mtimeMs,
                            size: stats.size,
                        });
                    }
                    else {
                        reject(err);
                    }
                });
            });
        },
        readDirectory: (uri) => {
            return new Promise((resolve, reject) => {
                fs.readdir(shared.uriToFsPath(uri), (err, files) => {
                    if (files) {
                        resolve(files.map(file => [file, html.FileType.File]));
                    }
                    else {
                        reject(err);
                    }
                });
            });
        },
    };
    const htmlLs = html.getLanguageService({ fileSystemProvider });
    const cssLs = css.getCSSLanguageService({ fileSystemProvider });
    const scssLs = css.getSCSSLanguageService({ fileSystemProvider });
    const lessLs = css.getLESSLanguageService({ fileSystemProvider });
    const pugLs = pug.getLanguageService(htmlLs);
    const jsonLs = json.getLanguageService({ schemaRequestService: vueHost === null || vueHost === void 0 ? void 0 : vueHost.schemaRequestService });
    const postcssLs = {
        ...scssLs,
        doValidation: (document, stylesheet, documentSettings) => {
            let errors = scssLs.doValidation(document, stylesheet, documentSettings);
            errors = errors.filter(error => error.code !== 'css-semicolonexpected');
            errors = errors.filter(error => error.code !== 'css-ruleorselectorexpected');
            errors = errors.filter(error => error.code !== 'unknownAtRules');
            return errors;
        },
    };
    return {
        ts,
        htmlLs,
        pugLs,
        jsonLs,
        getCssLs,
        vueHost,
    };
    function getCssLs(lang) {
        switch (lang) {
            case 'css': return cssLs;
            case 'scss': return scssLs;
            case 'less': return lessLs;
            case 'postcss': return postcssLs;
        }
    }
}
//# sourceMappingURL=languageService.js.map