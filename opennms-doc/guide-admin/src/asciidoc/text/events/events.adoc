
// Allow GitHub image rendering
:imagesdir: ../../images

Events are central to the operation of the {opennms-product-name} platform, so it's critical to have a firm grasp of this topic.

IMPORTANT: Whenever something in {opennms-product-name} appears to work by magic, it's probably events working behind the curtain.

[[ga-events-anatomy-of-an-event]]
=== Anatomy of an Event

Events are structured historical records of things that happen in {opennms-product-name} and the nodes, interfaces, and services it manages.
Every event has a number of fixed *fields* and zero or more *parameters*.

.Mandatory Fields
UEI (Universal Event Identifier)::
    A string uniquely identifying the event's type.
    UEIs are typically formatted in the style of a URI, but the only requirement is that they start with the string `uei.`.
Event Label::
    A short, static label summarizing the gist of all instances of this event.
Description::
    A long-form description describing all instances of this event.
Log Message::
    A long-form log message describing this event, optionally including expansions of fields and parameters so that the value is tailored to the event at hand.
Severity::
    A severity for this event type.
    Possible values range from `Cleared` to `Critical`.
Event ID::
    A numeric identifier used to look up a specific event in the {opennms-product-name} system.

.Notable Optional Fields
Operator Instruction::
    A set of instructions for an operator to respond appropriately to an event of this type.
Alarm Data::
    If this field is provided for an event, {opennms-product-name} will create, update, or clear *alarms* for events of that type according to the alarm-data specifics.

[[ga-events-sources-of-events]]
=== Sources of Events

Events may originate within {opennms-product-name} itself or from outside.

Internally-generated events can be the result of the platform's monitoring and management functions (_e.g._ a monitored node becoming totally unavailable results in an event with the UEI `uei.opennms.org/nodes/nodeDown`) or they may act as inputs or outputs of housekeeping processes.

The following subsections summarize the mechanisms by which externally-created events can arrive.

==== SNMP Traps

If SNMP-capable devices in the network are configured to send *traps* to {opennms-product-name}, these traps are transformed into events according to pre-configured rules. The `Trapd` service daemon, which enables {opennms-product-name} to receive SNMP traps, is enabled by default.

IMPORTANT: Disabling the `Trapd` service daemon will render {opennms-product-name} *incapable* of receiving SNMP traps.

Event definitions are included with {opennms-product-name} for traps from many vendors' equipment.

===== Traps forwarded via proxy
When SNMP traps are forwarded through a proxy using SNMPv2c or SNMPv3, preserving the original source IP address is a challenge due to the lack of an `agent-addr` field in the `TRAP-V2` PDU used in those protocol versions.
https://tools.ietf.org/html/rfc3584#page-42[RFC 3584] defines an optional varbind `snmpTrapAddress (.1.3.6.1.6.3.18.1.3.0)` which can be added to forwarded traps to convey the original source IP address.

To configure {opennms-product-name} to honor `snmpTrapAddress` when present, set `use-address-from-varbind="true"` in the top-level element of `${OPENNMS_HOME}/etc/trapd-configuration.xml` and restart {opennms-product-name}.

.Configuration example for using RFC 3584 helper varbinds in forwarded traps
[source, xml]
----
<trapd-configuration<1> snmp-trap-port="162" new-suspect-on-trap="false" use-address-from-varbind="true"<2>/>
----
<1> Top-level `trapd-configuration` element
<2> New attribute to enable use of `snmpTrapAddress` varbind, when present
==== Syslog Messages

Syslog messages sent over the network to {opennms-product-name} can be transformed into events according to pre-configured rules.

IMPORTANT: The `Syslogd` service daemon, which enables {opennms-product-name} to receive syslog messages over the network, must be enabled for this functionality to work. This service daemon is *disabled* by default.

===== Parsers

Different parsers can be used to convert the syslog message fields into {opennms-product-name} event fields.

[options="header, autowidth"]
|===
| Parser  | Description
| `org.opennms.netmgt.syslogd.CustomSyslogParser`    | Default parser that uses a regex statement to parse the syslog header.
| `org.opennms.netmgt.syslogd.RadixTreeSyslogParser` | Parser that uses an internal list of _grok_-style statements to parse the syslog header.
| `org.opennms.netmgt.syslogd.SyslogNGParser`        | Parser that strictly parses messages in the default pattern of syslog-ng.
| `org.opennms.netmgt.syslogd.Rfc5424SyslogParser`   | Parser that strictly parses the RFC 5424 format for syslog messages.
|===

====== RadixTreeSyslogParser

The `RadixTreeSyslogParser` normally uses a set of internally-defined patterns to parse multiple syslog message formats.
If you wish to customize the set of patterns, you can put a new set of patterns into a `syslog-grok-patterns.txt` in the `etc` directory for {opennms-product-name}.

The patterns are defined in _grok_-style statements where each token is defined by a `%{PATTERN:semantic}` clause.
Whitespace in the pattern will match 0...n whitespace characters and character literals in the pattern will match the corresponding characters.
The '%' character literal must be escaped by using a backslash, ie. '\%'.

NOTE: The RadixTreeSyslogParser's _grok_ implementation only supports a limited number of pattern types. However, these patterns should be sufficient to parse any syslog message format.

The patterns should be arranged in the file from most specific to least specific since the first pattern to successfully match the syslog message will be used to construct the {opennms-product-name} event.

[options="header, autowidth"]
|===
| Pattern   | Description
| `INT`     | Positive integer.
| `MONTH`   | 3-character English month abbreviation.
| `NOSPACE` | String that contains no whitespace.
| `STRING`  | String. Because this matches any character, it must be followed by a delimiter in the pattern string.
|===

[options="header, autowidth"]
|===
| Semantic Token | Description
| `day` | 2-digit day of month (1-31).
| `facilityPriority` | Facility-priority integer.
| `hostname` | String hostname (unqualified or FQDN), IPv4 address, or IPv6 address.
| `hour` | 2-digit hour of day (0-23).
| `message` | Remaining string message.
| `messageId` | String message ID.
| `minute` | 2-digit minute (0-59).
| `month` | 2-digit month (1-12).
| `processId` | String process ID.
| `processName` | String process name.
| `second` | 2-digit second (0-59).
| `secondFraction` | 1- to 6-digit fractional second value as a string.
| `timezone` | String timezone value.
| `version` | Version.
| `year` | 4-digit year.
|===

==== TL1 Autonomous Messages

Autonomous messages can be retrieved from certain TL1-enabled equipment and transformed into events.

IMPORTANT: The `Tl1d` service daemon, which enables {opennms-product-name} to receive TL1 autonomous messages, must be enabled for this functionality to work. This service daemon is *disabled* by default.

==== XML-TCP
Any application or script can create custom events in {opennms-product-name} by sending properly-formatted XML data over a TCP socket.

==== ReST

Posting an event in XML format to the appropriate endpoint in the {opennms-product-name} ReST API will cause the creation of a corresponding event, just as with the XML-TCP interface.

[[ga-events-event-bus]]
=== The Event Bus

At the heart of {opennms-product-name} lies an *event bus*.
Any {opennms-product-name} component can _publish_ events to the bus, and any component can _subscribe_ to receive events of interest that have been published on the bus.
This publish-subscribe model enables components to use events as a mechanism to send messages to each other.
For example, the provisioning subsystem of {opennms-product-name} publishes a _node-added_ event whenever a new node is added to the system.
Other subsystems with an interest in new nodes subscribe to the _node-added_ event and automatically receive these events, so they know to start monitoring and managing the new node if their configuration dictates.
The publisher and subscriber components do not need to have any knowledge of each other, allowing for a clean division of labor and lessening the programming burden to add entirely new {opennms-product-name} subsystems or modify the behavior of existing ones.

==== Associate an Event to a given node

There are 2 ways to associate an existing node to a given event prior sending it to the Event Bus:

* Set the *nodeId* of the node in question to the event.
* For requisitioned nodes, set the *_foreignSource* and *_foreignId* as parameters to the event. Then, any incoming event without a *nodeId* and these 2 parameters will trigger a lookup on the DB; if a node is found, the *nodeId* attribute will be dynamically set into the event, regardless which method has been used to send it to the *Event Bus*.
