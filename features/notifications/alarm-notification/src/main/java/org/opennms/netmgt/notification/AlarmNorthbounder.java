/**
 * /**************************************************************************
 * ***** This file is part of OpenNMS(R). Copyright (C) 2009-2011 The OpenNMS
 * Group, Inc. OpenNMS(R) is Copyright (C) 1999-2011 The OpenNMS Group, Inc.
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc. OpenNMS(R)
 * is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version. OpenNMS(R) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details. You should have received a copy of the GNU General Public
 * License along with OpenNMS(R). If not, see: http://www.gnu.org/licenses/
 * For more information contact: OpenNMS(R) Licensing <license@opennms.org>
 * http://www.opennms.org/ http://www.opennms.com/ This class is called
 * eachtime the alarm is generated by Alarmd. Filtering will be done and
 * required alarms will be forwarded from this class and associated classes.
 */

package org.opennms.netmgt.notification;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Properties;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.opennms.core.utils.ConfigFileConstants;
import org.opennms.netmgt.alarmd.api.NorthboundAlarm;
import org.opennms.netmgt.alarmd.api.NorthbounderException;
import org.opennms.netmgt.alarmd.api.support.AbstractNorthbounder;
import org.opennms.netmgt.dao.IpInterfaceDao;
import org.opennms.netmgt.dao.NodeDao;
import org.opennms.netmgt.dao.SnmpInterfaceDao;
import org.opennms.netmgt.model.OnmsIpInterface;
import org.opennms.netmgt.model.OnmsNode;
import org.opennms.netmgt.model.OnmsSnmpInterface;
import org.opennms.netmgt.notification.filter.AdvanceFilter;
import org.opennms.netmgt.notification.filter.DroolsFileLoader;
import org.opennms.netmgt.notification.parser.AlarmNorthbounderConfig;
import org.opennms.netmgt.notification.parser.AlarmNotificationConfigDao;
import org.opennms.netmgt.notification.parser.Errorhandling;
import org.opennms.netmgt.notification.parser.Filter;
import org.opennms.netmgt.notification.parser.Notification;
import org.opennms.netmgt.notification.parser.Script;
import org.opennms.netmgt.notification.parser.Uei;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AlarmNorthbounder extends AbstractNorthbounder{
	private static final Logger LOG = LoggerFactory.getLogger(AlarmNorthbounder.class);

	private AlarmNorthbounderConfig m_config;

	private NBIAlarmObjectFactory m_nbiAlarmObjectFactory;

	private JAXBContext m_context;

	private Marshaller m_marshaller;

	private Properties m_deviceFamilyProp = null;

	private NodeDao m_nodeDao;

	private SnmpInterfaceDao m_snmpInterfaceDao;

	private IpInterfaceDao m_ipInterfaceDao;

	private AlarmNotificationConfigDao m_alarmNotificationConfigDao;

	/**
	 * @param alarmNorthbounderConfig
	 * @throws JAXBException
	 */
	public AlarmNorthbounder(AlarmNorthbounderConfig alarmNorthbounderConfig)
			throws JAXBException {
		super("AlarmNorthbounder");
		m_nbiAlarmObjectFactory = NBIAlarmObjectFactory.getInstance();
		m_deviceFamilyProp = new Properties();
		try {
			File propFile = new File(ConfigFileConstants.getHome()
					+ "/etc/alarm-notification/devicefamily.properties");
			FileInputStream fstream = new FileInputStream(propFile);
			m_deviceFamilyProp.load(fstream);
		} catch (IOException e) {
			LOG.error("IOException while loading devicefamily.properties.IOException "
							+ e);
		} catch (Exception e) {
			LOG.error("Exception while loading devicefamily.properties.Exception "
							+ e);
		}
		m_context = JAXBContext.newInstance(AlarmList.class);
		m_marshaller = m_context.createMarshaller();
		m_marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
		m_config = alarmNorthbounderConfig;

	}

	@Override
	protected boolean accepts(NorthboundAlarm northboundalarm) {
		boolean isAlarmRequired = false;
		try {

			List<Notification> notificationList = m_config.getNotification();
			isAlarmRequired = iterateNotificationList(notificationList,
					northboundalarm);
			if (isAlarmRequired)
				return isAlarmRequired;
			else {
				LOG.debug(
						"Alarm with UEI "
								+ northboundalarm.getUei()

								+ " is not present in any of the notifications or the corresponding notifications are not enabled");
			}

		} catch (Exception e) {
			e.printStackTrace();
			LOG.error(" Exception in accepts method. Message is  ",
					e.getMessage());
			throw new NorthbounderException(e);
		}
		return isAlarmRequired;
	}

	/**
	 * Iterates through the notification list and compares if the received alarm
	 * is configured.
	 * 
	 * @param notificationList
	 * @param northboundalarm
	 * @return
	 */
	private boolean iterateNotificationList(
			List<Notification> notificationList, NorthboundAlarm northboundalarm)
			throws NorthbounderException {
		boolean isAlarmRequired = false;
		try {
			Iterator<Notification> notificationIterator = notificationList
					.iterator();
			/**
			 * Check if the UEI matches with any of the notification.Returns
			 * true if atleast one notification matches.
			 */
			while (notificationIterator.hasNext()) {

				Notification notification = notificationIterator.next();
				boolean isNotificationEnabled = notification.isEnable();
				/**
				 * Check only if the notification is enabled.
				 */
				if (isNotificationEnabled) {
					List<Uei> ueiList = notification.getUeis().getUei();
					Iterator<Uei> ueiListIterator = ueiList.iterator();
					while (ueiListIterator.hasNext()) {
						Uei uei = ueiListIterator.next();
						String configuredUei = uei.getName();
						String receivedUei = northboundalarm.getUei();
						String clearKey = northboundalarm.getClearKey();
						if (configuredUei.equals(receivedUei)
								|| (clearKey != null && clearKey
										.contains(configuredUei))) {

							LOG.debug("The UEI " + configuredUei
									+ " is configured for alarm notification.");
							int notificationThreshold = 0;
							try{
								notificationThreshold = Integer.parseInt(uei.getNotificationThreshold());
							}catch(NumberFormatException n) {
								LOG.error("Notification Threshold " + uei.getNotificationThreshold() + 
										" is not a valid integer.Taking default value which is 5");
								notificationThreshold = 5;
							}
							int alarmCount = northboundalarm.getCount();
							if(notificationThreshold == 0) {
								LOG.debug("Notification Threshold cannot be 0.Taking default value which is 5");
								notificationThreshold = 5;
							}
							
							if(alarmCount % notificationThreshold != 1 && notificationThreshold != 1 ) {
								isAlarmRequired = false;
								LOG.debug("The northbound alarm count " + alarmCount +" does not match thresholdNotification " + notificationThreshold);
							}else {
								LOG.debug("The northbound alarm count " + alarmCount +" matches thresholdNotification " + notificationThreshold);
								isAlarmRequired = true;
							}
							return isAlarmRequired;
						} else if (northboundalarm.getUei().equals(
								"uei.opennms.org/vacuumd/juniper/alarmCleared")) {
							if (northboundalarm.getEventParms().contains(
									configuredUei)) {
								
								String reductionKey = northboundalarm.getAlarmKey().split("-")[0];

								LOG.debug(
										"The alarm with reductionKey"
												+ reductionKey
												+ " is configured and is cleared from UI.");

								isAlarmRequired = true;
								return isAlarmRequired;
							}
						}
					}
				} else {
					LOG.debug(
							"Notification "
									+ notification.getName()
									+ " is not enabled and basic filter check not done.");
					isAlarmRequired = false;
				}
			}
		} catch (Exception e) {
			LOG.error("Error :: in iterateNotificationList method"
					+ e.getMessage());
			throw new NorthbounderException(e);
		}
		return isAlarmRequired;
	}

	/**
	 * Checks if the configured device family matches with the received alarm.
	 * 
	 * @param basicFilter
	 * @param sysoid
	 * @return
	 */
	private boolean isDeviceFamilyConfigured(Filter basicFilter, String sysoid) {
		boolean alarmBoolean = true;
		try {

			String deviceFamilyFromNotifList = basicFilter.getDevicefamily();
			if (deviceFamilyFromNotifList == null
					|| deviceFamilyFromNotifList.isEmpty()) {
				LOG.debug("Device Family Not Configured.");
				return alarmBoolean;
			} else if (deviceFamilyFromNotifList.equals("DevicesWithNoSysoid")
					&& (sysoid == null || sysoid.isEmpty())) {
				LOG.debug("DevicesWithNoSysoid matches");
				return alarmBoolean;
			} else if ((sysoid == null || sysoid.isEmpty())
					&& (deviceFamilyFromNotifList != null || !deviceFamilyFromNotifList
							.isEmpty())) {
				alarmBoolean = false;
				LOG.debug(
						"Sysoid is not present for the received alarm but the device family filter "
								+ "is configured.Notification will not be sent.");
				return alarmBoolean;
			} else {
				alarmBoolean = false;

			for (Entry<Object, Object> deviceFamilyEntries : m_deviceFamilyProp.entrySet()) {

				String value = deviceFamilyEntries.getValue().toString().trim();
				if (value.equals(deviceFamilyFromNotifList.trim())) {
					String sysoidOfDeviceFamily = deviceFamilyEntries.getKey()
							.toString().trim();
					if (sysoid.contains(sysoidOfDeviceFamily)) {
						LOG.debug("Received Device Family "
								+ sysoidOfDeviceFamily + "matches.");
						alarmBoolean = true;
						break;
					} else {
						LOG.debug(
								"Device Family does not match matches.Configured :"
										+ sysoidOfDeviceFamily
										+ " NorthBoundAlarm Device Family :"
										+ sysoid);
						alarmBoolean = false;
					}
				}

			}
			}
		} catch (Exception e) {
			LOG.error(
					"Error while checking if device family configured : "
							+ e.getMessage());
			throw new NorthbounderException(e);
		}
		return alarmBoolean;
	}

	/**
	 * Checks if the configured severity matches with the received alarm.
	 * 
	 * @param basicFilter
	 * @param northBoundAlarmSeverity
	 * @return
	 */
	private boolean isSeverityConfigured(Filter basicFilter,
			String northBoundAlarmSeverity) {
		boolean alarmBoolean = true;
		String severityFromNotifList = basicFilter.getSeverity();
		if (severityFromNotifList == null || severityFromNotifList.isEmpty()) {
			LOG.debug("Severity is not configured.");
			return alarmBoolean;
		}

		if (severityFromNotifList.contains(northBoundAlarmSeverity)) {
			alarmBoolean = true;
			LOG.debug("Received Severity "
					+ northBoundAlarmSeverity + " matches.");
		} else {
			LOG.debug("Severity does not matches.Configured : "
					+ severityFromNotifList + " NorthBoundAlarmSeverity :"
					+ northBoundAlarmSeverity);
			alarmBoolean = false;
		}
		return alarmBoolean;
	}

	@Override
	public void forwardAlarms(List<NorthboundAlarm> northBoundAlarmList)
			throws NorthbounderException {
		/**
		 * Compare each of the alarm in the list with the notifications list
		 * from the xml.
		 */

		List<Notification> notificationList = m_config.getNotification();
		for (int i = 0; i < northBoundAlarmList.size(); i++) {
			NorthboundAlarm northboundalarm = northBoundAlarmList.get(i);
			Notification notification = null;
			for (int j = 0; j < notificationList.size(); j++) {
				try {
					notification = notificationList.get(j);
					LOG.debug(
							"Checking if " + northboundalarm.getUei()
									+ " is configured in notification "
									+ notification.getName());
					boolean isNotified = processNotification(notification,
							northboundalarm);
					LOG.warn("UEI configuration status of "
							+ northboundalarm.getUei() + " in notification "
							+ notification.getName() + " is " + isNotified);
				} catch (NorthbounderException e) {
					e.printStackTrace();
					LOG.error(
							"Error in alarm notification for north bound alarm with uei " +northboundalarm.getUei() + " while processing the " +
									"notification " + notification.getName());
				}
			}
		}
	}

	/**
	 * @param notification
	 * @param northboundalarm
	 * @return
	 * @throws NorthbounderException
	 */
	private boolean processNotification(Notification notification,
			NorthboundAlarm northboundalarm) throws NorthbounderException {
		boolean isAlarmRequired = false;
		try {
			if (notification.isEnable()) {
				List<Uei> ueiList = notification.getUeis().getUei();
				Iterator<Uei> ueiListIterator = ueiList.iterator();
				while (ueiListIterator.hasNext()) {
					Uei uei = ueiListIterator.next();
					isAlarmRequired = isUeiConfigured(uei, northboundalarm);
					if (isAlarmRequired) {
						boolean isNotified = notifyAlarm(notification,
								northboundalarm);
						LOG.debug(
								"Script Invoker status of alarm with UEI "
										+ uei.getName()
										+ " w.r.t basic filter in notification "
										+ notification.getName() + " is "
										+ isNotified);
						return isAlarmRequired;
					} else {
						LOG.debug("Alarm with UEI "
								+ northboundalarm.getUei()
								+ " need not be notified w.r.t notification "
								+ notification.getName());

					}
				}
			} else {
				LOG.warn("Notification " + notification.getName()
						+ " is not enabled.");
			}
		} catch (Exception e) {
			LOG.error(
					"Error in method processNotification. Message is  "
							+ e.getMessage());
			throw new NorthbounderException(e);
		}
		return isAlarmRequired;
	}

	/**
	 * Checks if the received northboundalarm uei matches with any of the
	 * configured UEIs
	 * 
	 * @param uei
	 * @param northboundalarm
	 * @return
	 * @throws NorthbounderException
	 */
	private boolean isUeiConfigured(Uei uei, NorthboundAlarm northboundalarm)
			throws NorthbounderException {
		LOG.debug(
				"In method isUeiConfigured for NorthboundAlarm with UEI  "
						+ northboundalarm.getUei());
		boolean isAlarmRequired = false;
		try {
			String configuredUei = uei.getName().trim();
			String receivedUei = northboundalarm.getUei().trim();
			String clearKey = northboundalarm.getClearKey();
			String uiClear = "uei.opennms.org/vacuumd/juniper/alarmCleared";
			String eventParms = northboundalarm.getEventParms();
			if ((configuredUei.equals(receivedUei)) //Check if it error event is configured
					|| (clearKey != null && clearKey.contains(configuredUei)) //Check if error event corresponding to received clear event is configured
					|| (receivedUei.equals(uiClear) && eventParms //Check if error event cleared from UI is configured
							.contains(configuredUei))) {
				boolean uiclear = false;
				if (receivedUei.equals(uiClear)) {
					uiclear = true;
				}
				isAlarmRequired = true;
				List<Filter> filterList = uei.getFilter();
				Iterator<Filter> filterIterator = filterList.iterator();

				while (filterIterator.hasNext()) {
					Filter basicFilter = filterIterator.next();
					isAlarmRequired = isAlarmConfiguredByBasicFilter(
							northboundalarm, basicFilter);
					if (!isAlarmRequired && !uiclear) {
						LOG.debug(
								"Uei " + northboundalarm.getAlarmKey()
										+ " is not configured.");

					}
					if (!isAlarmRequired && uiclear) {
						String reductionKey = northboundalarm.getAlarmKey().split("-")[0];
						LOG.debug(
								"Alarm cleared from UI with reduction key  "
										+ reductionKey + " is not configured or the filter is not matched.");

					} else if (isAlarmRequired)
						break;
				}

			} else {
				LOG.debug("Uei " + uei.getName()
						+ " does not match with " + northboundalarm.getUei());
			}
		} catch (Exception e) {
			LOG.error(
					"Error in method isUeiConfigured. Message is  "
							+ e.getMessage());
			throw new NorthbounderException(e);
		}
		return isAlarmRequired;
	}

	/**
	 * Checks if the received alarm severity matches with the configured
	 * severity
	 * 
	 * @param northboundalarm
	 * @param basicFilter
	 * @return
	 * @throws NorthbounderException
	 */
	private boolean isAlarmConfiguredByBasicFilter(
			NorthboundAlarm northboundalarm, Filter basicFilter)
			throws NorthbounderException {
		boolean isAlarmRequired = true;
		try {
			if (basicFilter == null)
				return isAlarmRequired;
			isAlarmRequired = isSeverityConfigured(basicFilter, northboundalarm
					.getSeverity().getLabel());
			if (!isAlarmRequired)
				return isAlarmRequired;
			String sysoid = null;
			Integer nodeId = northboundalarm.getNodeId();
			if (nodeId == null || nodeId == 0) {
				LOG.debug("Node id is " + nodeId + ".");
			}
			if (nodeId != null) {
				List<OnmsNode> onmsNodeList = m_nodeDao.findByLabel(m_nodeDao
						.getLabelForId(nodeId));
				if (onmsNodeList != null) {
					for (int i = 0; i < onmsNodeList.size(); i++) {
						OnmsNode onmsNode = onmsNodeList.get(i);
						if (Integer.toString(nodeId).equals(onmsNode.getNodeId())) {
							sysoid = onmsNode.getSysObjectId();
							break;
						} else
							continue;
					}
				}
			}
			isAlarmRequired = isDeviceFamilyConfigured(basicFilter, sysoid);
			LOG.debug("Device family check status " + isAlarmRequired);

		} catch (Exception e) {
			LOG.error(
					"Error in method isAlarmConfiguredByBasicFilter. Message is  "
							+ e.getMessage());
			throw new NorthbounderException(e);
		}
		return isAlarmRequired;
	}

	/**
	 * Invokes the script if the basic filter passes and there is no
	 * corresponding advance filter.
	 * 
	 * @param notification
	 * @param northboundalarm
	 * @return
	 * @throws NorthbounderException
	 */
	private boolean notifyAlarm(Notification notification,
			NorthboundAlarm northboundalarm) throws NorthbounderException {
		boolean scriptInvokerResult = false;
		try {
			Script script = notification.getScript();
			// Convert the object to string in xml format.
			NBIAlarm nbiAlarm = null;
			if (northboundalarm.getUei().equals(
					"uei.opennms.org/vacuumd/juniper/alarmCleared"))
				nbiAlarm = createUiClearAlarm(northboundalarm);
			else
				nbiAlarm = createNBIAlarm(northboundalarm);
			AlarmList nbiAlarmList = m_nbiAlarmObjectFactory.createAlarmList(
					nbiAlarm, null);
			String alarmsXML = convertToXml(nbiAlarmList);
			AdvanceFilter advanceFilter = new AdvanceFilter();
			boolean isAdvanceFilterPresent = advanceFilter.callAdvanceFilter(
					nbiAlarm, notification.getName(), alarmsXML, script);
			if (isAdvanceFilterPresent == false) {
				LOG.debug("Script " + script.getScriptname()
						+ " to be invoked for North bound alarm list "
						+ nbiAlarmList.toString());
				Errorhandling errorHandling = script.getErrorhandling();
				ScriptInvoker scriptInvoker = new ScriptInvoker(alarmsXML,
						script.getScriptname(),script.getTimeoutInSeconds(), errorHandling.isEnable(),
						errorHandling.getNumberOfRetries(),
						errorHandling.getRetryIntervalInseconds());
				scriptInvokerResult = scriptInvoker.invokeScript();
			} else {
				LOG.debug(
						"Advance filtering is done by drl file for notification "
								+ notification.getName());
			}

			return scriptInvokerResult;
		} catch (Exception e) {
			LOG.error("Error in method notifyAlarm. Message is  "
					+ e.getMessage());
			throw new NorthbounderException(e);
		}

	}

	/**
	 * Converts the nbialarmlist xml object to string
	 * 
	 * @param northboundalarm
	 * @return String
	 */
	private String convertToXml(AlarmList nbiAlarmList)
			throws NorthbounderException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		try {
			m_marshaller.marshal(nbiAlarmList, out);
			String xml = out.toString();
			LOG.debug("XML to be forwarded is  " + xml);
			return xml;
		} catch (Exception e) {
			LOG.error("Failed to convert nbialarms to xml",
					e.getMessage());
			throw new NorthbounderException(e);
		}
	}

	/**
	 * Checks if the argument is null. If not null returns the corresponding
	 * string object. Else returns null. This method avoids null pointer
	 * exception
	 * 
	 * @param date
	 * @return String
	 */
	private String getDateString(Date date) {
		String dateStr = null;
		if (date != null)
			dateStr = date.toString();
		return dateStr;
	}

	/**
	 * Creates NBIAlarm object from NorthboundAlarm object.This object is used
	 * by drl files.
	 * 
	 * @param northboundalarm
	 * @return
	 * @throws NorthbounderException
	 */
	private NBIAlarm createNBIAlarm(NorthboundAlarm northboundalarm)
			throws NorthbounderException {
		NBIAlarm nbiAlarm = m_nbiAlarmObjectFactory.createAlarm();
		try {
			nbiAlarm.setAlarmid(String.valueOf(northboundalarm.getId()));
			nbiAlarm.setEventuei(northboundalarm.getUei());
			if (northboundalarm.getPoller() != null)
				nbiAlarm.setDpname(northboundalarm.getPoller().getName());
			if (northboundalarm.getIpAddr() != null)
				nbiAlarm.setIpaddr(northboundalarm.getIpAddr().getHostAddress());
			if (northboundalarm.getService() != null)
				nbiAlarm.setServiceid(String.valueOf(northboundalarm
						.getService().getId()));

			nbiAlarm.setReductionkey(northboundalarm.getAlarmKey());

			if (northboundalarm.getAlarmType() != null)
				nbiAlarm.setAlarmtype(northboundalarm.getAlarmType().name());

			nbiAlarm.setCounter(String.valueOf(northboundalarm.getCount()));

			nbiAlarm.setSeverity(String.valueOf(northboundalarm.getSeverity()
					.getId()));
			nbiAlarm.setFirsteventtime(getDateString(northboundalarm
					.getFirstOccurrence()));
			nbiAlarm.setLasteventtime(getDateString(northboundalarm
					.getLastOccurrence()));
			nbiAlarm.setDescription(northboundalarm.getDesc());
			nbiAlarm.setLogmsg(northboundalarm.getLogMsg());
			nbiAlarm.setOperinstruct(northboundalarm.getOperInst());
			nbiAlarm.setTticketid(northboundalarm.getTicketId());

			if (northboundalarm.getTicketState() != null)
				nbiAlarm.setTticketstate(northboundalarm.getTicketState()
						.name());
			nbiAlarm.setSuppresseduntil(getDateString(northboundalarm
					.getSuppressedUntil()));
			nbiAlarm.setSuppresseduser(northboundalarm.getSuppressedBy());
			nbiAlarm.setSuppressedtime(getDateString(northboundalarm
					.getSuppressed()));
			nbiAlarm.setAlarmackuser(northboundalarm.getAckUser());
			nbiAlarm.setAlarmacktime(getDateString(northboundalarm.getAckTime()));
			nbiAlarm.setApplicationdn(northboundalarm.getAppDn());
			nbiAlarm.setOssprimarykey(northboundalarm.getOssKey());
			nbiAlarm.setX733Alarmtype(northboundalarm.getX733Type());
			nbiAlarm.setX733Probablecause(String.valueOf(northboundalarm
					.getX733Cause()));
			nbiAlarm.setClearkey(northboundalarm.getClearKey());
			nbiAlarm.setEventparms(northboundalarm.getEventParms());
			Integer nodeId = northboundalarm.getNodeId();
			OnmsIpInterface onmsIpInterface = null;
			String ipaddr = northboundalarm.getIpAddr().getHostAddress();
			if (m_ipInterfaceDao != null && nodeId != null && ipaddr != null ) {
				Integer ifIndex = null;
				
				onmsIpInterface = m_ipInterfaceDao.findByNodeIdAndIpAddress(
						nodeId, ipaddr);
				
				if (onmsIpInterface != null) {
					try{
						ifIndex = onmsIpInterface.getIfIndex();
					}catch(Exception e){
						LOG.error("Error while getting index for node "
								+ northboundalarm.getNodeId() + e.getMessage());
						ifIndex = null;
					}
					if (ifIndex != null) {
						nbiAlarm.setIfindex(String.valueOf(ifIndex));
						OnmsSnmpInterface onmsSnmpInterface = m_snmpInterfaceDao
								.findByNodeIdAndIfIndex(nodeId, ifIndex);
						String ifName = onmsSnmpInterface.getIfName();
						nbiAlarm.setIfname(ifName);
					}
				}
			}

		} catch (Exception e) {
			LOG.error("Error while creating NBIAlarm for "
					+ northboundalarm.toString() + e.getMessage());
			throw new NorthbounderException(e);
		}
		return nbiAlarm;
	}

	/**
	 * NBIAlarm to be created when an alarm is cleared from UI.
	 * 
	 * @param northboundalarm
	 * @return
	 */
	private NBIAlarm createUiClearAlarm(NorthboundAlarm northboundalarm)
			throws NorthbounderException {

		NBIAlarm nbiAlarm = m_nbiAlarmObjectFactory.createAlarm();
		try {
			nbiAlarm.setUiclear("uiclear");
			String alarmId = northboundalarm.getAlarmKey().split("-")[1];
			nbiAlarm.setAlarmid(alarmId);
			String reductionKey = northboundalarm.getAlarmKey().split("-")[0];
			nbiAlarm.setReductionkey(reductionKey);
			String ipaddr = northboundalarm.getIpAddr().getHostAddress();
			nbiAlarm.setIpaddr(ipaddr);
			Integer nodeId = northboundalarm.getNodeId();
			OnmsIpInterface onmsIpInterface = null;
			if (m_ipInterfaceDao != null && nodeId != null && ipaddr != null) {
				onmsIpInterface = m_ipInterfaceDao.findByNodeIdAndIpAddress(
						nodeId, ipaddr);
				Integer ifIndex = null;
				if (onmsIpInterface != null) {
					try{
						ifIndex = onmsIpInterface.getIfIndex();
					}catch(Exception e){
						LOG.error("Error while getting index for node "
								+ northboundalarm.getNodeId() + e.getMessage());
						ifIndex = null;
					}
					if (ifIndex != null) {
						nbiAlarm.setIfindex(String.valueOf(ifIndex));
						OnmsSnmpInterface onmsSnmpInterface = m_snmpInterfaceDao
								.findByNodeIdAndIfIndex(nodeId, ifIndex);
						String ifName = onmsSnmpInterface.getIfName();
						nbiAlarm.setIfname(ifName);
					}
				}
			}
		} catch (Exception e) {
			LOG.error("Error while creating UI Clear NBIAlarm for "
					+ northboundalarm.toString() + e.getMessage());
			throw new NorthbounderException(e);
		}
		return nbiAlarm;

	}

	public NodeDao getNodeDao() {
		return m_nodeDao;
	}

	public void setNodeDao(NodeDao nodeDao) {
		m_nodeDao = nodeDao;
	}

	public SnmpInterfaceDao geSnmpInterfaceDao() {
		return m_snmpInterfaceDao;
	}

	public void setSnmpInterfaceDao(SnmpInterfaceDao snmpInterfaceDao) {
		this.m_snmpInterfaceDao = snmpInterfaceDao;
	}

	public IpInterfaceDao getIpInterfaceDao() {
		return this.m_ipInterfaceDao;
	}

	public void setIpInterfaceDao(IpInterfaceDao ipInterfaceDao) {
		this.m_ipInterfaceDao = ipInterfaceDao;
	}

	public AlarmNotificationConfigDao getAlarmNotificationConfigDao() {
		return m_alarmNotificationConfigDao;
	}

	public void setAlarmNotificationConfigDao(
			AlarmNotificationConfigDao m_alarmNotificationConfigDao) {
		this.m_alarmNotificationConfigDao = m_alarmNotificationConfigDao;
	}

	private boolean loadDroolFiles() {
		DroolsFileLoader droolsFileLoader = new DroolsFileLoader("reloadDrl");
		boolean drlReloadStatus = droolsFileLoader.reloadDroolFiles();
		return drlReloadStatus;

	}

	private boolean loadDeviceFamilyProperties() {
		m_deviceFamilyProp = new Properties();
		try {
			File propFile = new File(ConfigFileConstants.getHome()
					+ "/etc/alarm-notification/devicefamily.properties");
			FileInputStream fstream = new FileInputStream(propFile);
			m_deviceFamilyProp.load(fstream);
			LOG.debug("Device family Properties loaded successfully.");
		} catch (IOException e) {
			e.printStackTrace();
			LOG.error("IOException while loading devicefamily.properties.IOException "
							+ e.getMessage());
			return false;
		} catch (Exception e) {
			e.printStackTrace();
			LOG.error("Exception while loading devicefamily.properties.Exception "
							+ e.getMessage());
			return false;
		}
		return true;
	}

	private boolean loadAlarmNotificationConf() {
		try {
			Resource resource = new FileSystemResource(ConfigFileConstants.getHome()+
					"/etc/alarm-notification/alarmNotificationConf.xml");
			m_alarmNotificationConfigDao.setConfigResource(resource);
			m_alarmNotificationConfigDao.afterPropertiesSet();
			m_config = m_alarmNotificationConfigDao.getConfig();
			LOG.debug("Alarm Notfication Config file loaded successfully.");
		
		} catch (Exception e) {
			e.printStackTrace();
			LOG.error("Error in AlarmNorthBounder in reloading alarmNotificationconf.xml" + e.getMessage());
			return false;
		}
		
		return true;
	}

	@Override
	public void reloadConfig() {
		
		boolean confBoolean = loadAlarmNotificationConf();
		boolean deviceFamilyBoolean = loadDeviceFamilyProperties();
		boolean drlBoolean = loadDroolFiles();
		
		if(confBoolean ==true && deviceFamilyBoolean == true && drlBoolean == true)
			LOG.info("Alarm North bounder configuartion changes loaded suucessfuly.");
		else
			LOG.error("One or more alarm north bounder config files are not loaded properly.");
	}
}
